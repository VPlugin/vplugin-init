/*
 * vplugin-init - A simple program to create a new plugin for the VPlugin framework.
 * Copyright (C) 2022  Aggelos Tselios
 *
 * vplugin-init is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * vplugin-init is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with vplugin-init.  If not, see <https://www.gnu.org/licenses/>.
*/

extern crate console;
extern crate toml;

use console::Style;
use crate::file::FileManager;
use std::{fs};
use toml::{map::Map, Value};

#[allow(dead_code)]
const MAIN_FILE_CONTENTS: &str = 
"/*
 * Autogenerated file from vplugin-init.
 * This file contains your plugin's entry point.
 */

#[no_mangle]
fn vplugin_init() -> u32 {
        println!(\"Hello World!\");
        return 0;
}
";

pub struct Application;

impl Application {
        fn print_initial_info() {
                let color       = Style::new().yellow().bold();
                let bright      = Style::new().bright().bold().white();
                println!("{}", color.apply_to("    vplugin-init - A utility program to generate a VPlugin module."));
                println!("{}{}", bright.apply_to(" • Version: "), "\t0.1.0");
                println!("{}{}", bright.apply_to(" • GitHub Repo: "), "https://github.com/AndroGR/vplugin-init");
                println!("{}{}", bright.apply_to(" • Running on:  "), std::env::consts::OS);
                println!();
        }

        pub fn print_debug(prefix_console: &str, msg: &str) {
                let prefix = Style::new().bold().bright().green();
                println!("{}: {}", prefix.apply_to(prefix_console), msg);
        }

        pub fn print_error(msg: &str) {
                let prefix = Style::new().bold().bright().red();
                println!("{}{}", prefix.apply_to("ERROR: "), msg);
        }

        pub fn init_directory(plugin_name: &str, version: &str) {
                FileManager::new_directory("src/"  );
                FileManager::new_file("README.md"  );

                match fs::write("src/lib.rs", MAIN_FILE_CONTENTS) {
                        Ok (_) => (),
                        Err(e) => {
                                let msg = format!(
                                        "Failed to write entry file src/lib.rs
                                        during creation (errcode {}, {}).
                                        ",
                                        e.raw_os_error().unwrap(),
                                        e.to_string()
                                );
                                Self::print_error(&msg);
                        }
                }
                Application::create_config_file(plugin_name, version);
        }

        pub fn create_config_file(plugin_name: &str, version: &str) {
                let mut config_file = Map::new();

                config_file.insert("name".into(),    Value::String(plugin_name.to_string()));
                config_file.insert("version".into(), Value::String(version.to_string()));
                config_file.insert("metadata".into(),      Value::Table(config_file.clone()));
                
                let table       = Value::Table(config_file);
                let toml_string = toml::to_string(&table).unwrap();

                fs::write("metadata.toml", toml_string).unwrap();
        }

        pub fn run(
                plugin_name: String,
                version    : String,
                directory  : Option<&String>,
                language   : Option<&String>
        ) -> Result<(), String> {
                Application::print_initial_info();

                Application::print_debug("Plugin Name", &plugin_name);
                Application::print_debug("Plugin Version", &version);

                if directory.is_some() {
                        Application::print_debug("Directory chosen", directory.unwrap());
                }

                if language.is_some() {
                        Application::print_debug("Language chosen", language.unwrap());
                }
                println!();

                if directory.is_some() {
                        if directory.unwrap() != "." {
                                FileManager::new_directory(directory.unwrap());
                        }
                        std::env::set_current_dir(directory.unwrap()).unwrap();
                }

                Application::print_debug("Current directory", &std::env::current_dir().unwrap().display().to_string());
                Application::init_directory(&plugin_name, &version);

                Ok(())
        }
}