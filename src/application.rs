/*
 * vplugin-init - A simple program to create a new plugin for the VPlugin framework.
 * Copyright (C) 2022  Aggelos Tselios
 *
 * vplugin-init is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * vplugin-init is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with vplugin-init.  If not, see <https://www.gnu.org/licenses/>.
*/

extern crate console;
extern crate toml;

use console::Style;
use crate::file::FileManager;
use core::panic;
use std::{fs};
use toml::{map::Map, Value};

const MAIN_FILE_CONTENTS: &str =
"/*
 * Autogenerated file from vplugin-init.
 * This file contains your plugin's entry point.
 */

#[no_mangle]
fn vplugin_init() -> i32 {
        println!(\"Hello World!\");
        return 0;
}
";

const MAIN_FILE_CONTENTS_C: &str =
"
/*
 * Autogenerated file contents, from vplugin-init.
 * This file contains your plugin's entry point, and is targeting
 * plugins for the C / C++ language.
 */
#include <stdint.h>
#include <stdio.h>

int vplugin_init() {
     puts(\"Hello World!\");
     return 0;
}

void vplugin_exit() {
     puts(\"Goodbye world!\");
     return;
}
";

const MAIN_FILE_CONTENTS_CPP: &str =
"
/*
 * Autogenerated file contents, from vplugin-init.
 * This file contains your plugin's entry point, and is targeting
 * plugins for the C++ language.
 */

#include <cstdint>
#include <iostream>

extern \"C\" { 

int32_t vplugin_init() noexcept {
        std::cout << \"Hello World!\" << std::endl;
        return 0;
}

void vplugin_exit() noexcept {
        std::cout << \"Goodbye World!\" << std::endl;
        return;
}

} // extern \"C\"
";
pub struct Application;

pub enum PluginLanguage {
        C,
        CXX,
        Rust
}

impl Application {
        fn print_initial_info() {
                let color       = Style::new().yellow().bold();
                let bright      = Style::new().bright().bold().white();
                println!("{}",   color .apply_to("    vplugin-init - A utility program to generate a VPlugin module."));
                println!("{}{}", bright.apply_to(" • Version: "), "\t0.1.0");
                println!("{}{}", bright.apply_to(" • GitHub Repo: "), "https://github.com/AndroGR/vplugin-init");
                println!("{}{}", bright.apply_to(" • Running on:  "), std::env::consts::OS);
                println!();
        }

        pub fn print_debug(prefix_console: &str, msg: &str) {
                let prefix = Style::new().bold().bright().green();
                println!("{}: {}", prefix.apply_to(prefix_console), msg);
        }

        pub fn print_error(msg: &str) {
                let prefix = Style::new().bold().bright().red();
                println!("{}{}", prefix.apply_to("ERROR: "), msg);
        }

        pub fn init_directory(language: PluginLanguage, plugin_name: &str, version: &str) {
                FileManager::new_directory("src/");
                FileManager::new_file("README.md");

                let filename = match language {
                        PluginLanguage::C    => "src/plugin.c",
                        PluginLanguage::CXX  => "src/plugin.cc",
                        PluginLanguage::Rust => "src/plugin.rs",
                };

                let contents = match language {
                        PluginLanguage::C    => MAIN_FILE_CONTENTS_C,
                        PluginLanguage::CXX  => MAIN_FILE_CONTENTS_CPP,
                        PluginLanguage::Rust => MAIN_FILE_CONTENTS,
                };


                match fs::write(filename, contents) {
                        Ok (_) => (),
                        Err(e) => {
                                let msg = format!(
                                        "Failed to write entry file src/lib.rs
                                        during creation (errcode {}, {}).
                                        ",
                                        e.raw_os_error().unwrap(),
                                        e.to_string()
                                );
                                Self::print_error(&msg);
                        }
                }
                Application::create_config_file(plugin_name, version);
        }

        pub fn create_config_file(plugin_name: &str, version: &str) {
                let mut config_file = Map::new();

                config_file.insert("name".into(),    Value::String(plugin_name.to_string()));
                config_file.insert("version".into(), Value::String(version.to_string()));
                config_file.insert("metadata".into(),      Value::Table(config_file.clone()));
                
                let table       = Value::Table(config_file);
                let toml_string = toml::to_string(&table).unwrap();

                fs::write("metadata.toml", toml_string).unwrap();
        }

        pub fn run(
                plugin_name: String,
                version    : String,
                language   : String,
                directory  : Option<&String>,
        ) -> Result<(), String> {
                Application::print_initial_info();

                Application::print_debug("Plugin Name", &plugin_name);
                Application::print_debug("Plugin Version", &version);

                if directory.is_some() {
                        Application::print_debug("Directory chosen", directory.unwrap());
                }

                let lang = match language.as_str() {
                        "rust" => PluginLanguage::Rust,
                        "c"    => PluginLanguage::C,
                        "cpp"  => PluginLanguage::CXX,
                        _      => panic!("No valid language specified!")
                };

                println!();

                if directory.is_some() {
                        if directory.unwrap() != "." {
                                FileManager::new_directory(directory.unwrap());
                        }
                        std::env::set_current_dir(directory.unwrap()).unwrap();
                }

                Application::print_debug("Current directory", &std::env::current_dir().unwrap().display().to_string());
                Application::init_directory(lang, &plugin_name, &version);

                Ok(())
        }
}